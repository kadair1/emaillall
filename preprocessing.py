# -*- coding: utf-8 -*-
"""preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rq8lFiEfksWZegzkPeJE-9YrmtnpsD2T
"""

import pandas as pd
enron = pd.read_csv('/Users/vchintalapati/Downloads/emails.csv')

enron.head(5)

enron['message'][3]

prompt_head = """
<context>
I will feed you a lot of emails from Enron, which are a mix of both internal and external emails from Enron.

My goal is to create a high quality dataset which contains the Subject and Body of emails, specifically external emails of Enron.


Your task is to take all the emails I give you, and to output the emails which you believe are external emails, with the subject and body in the below format. Do not manipulate the content of the Subject and Body, just put them in the specific format I shared with you.

{"text":""}

You need to provide the prompts in this JSON format:
{ "simplePrompt": "", "advancedPrompt": "" }
Here is an example:
<examples>
{"text":"<subject>Receipt of Team Selection Form - Executive Impact & Influence</subject><body>Hi Phillip.  We appreciate your prompt attention and completing the Team
Selection information.
Ideally, we needed to receive your team of raters on the Team Selection form
we sent you.  The information needed is then easily transferred into the
database directly from that Excel spreadsheet.  If you do not have the
ability to complete that form, inserting what you listed below, we still
require additional information.
We need each person's email address.  Without the email address, we cannot
email them their internet link and ID to provide feedback for you, nor can
we send them an automatic reminder via email.  It would also be good to have
each person's phone number, in the event we need to reach them.
</body>"}
</examples>

</context>

REMEMBER, your job is to identify the external emails only, and ONLY use them to the output in the requested format. If you think
"""

import pandas as pd
import re

def extract_subject_and_body_v2(msg):
    # Extract body using the position of "X-FileName:"
    body_start_pos = msg.find("X-FileName:")
    body = msg[body_start_pos:].split("\n\n", 1)[-1] if body_start_pos != -1 else None

    # Extract subject using the "Subject:" tag
    subject_match = re.search(r"Subject: (.*?)\n", msg)
    subject = subject_match.group(1) if subject_match else "No Subject Found"

    return subject, body

def process_enron_emails(input_filepath, output_filepath=None):
    # Load the CSV from the provided filepath
    enron_df = pd.read_csv(input_filepath)

    # Apply the extraction method to the 'message' column to populate the "Subject" and "Body" columns
    enron_df['Subject'], enron_df['Body'] = zip(*enron_df['message'].apply(extract_subject_and_body_v2))

    # If no output filepath is provided, save next to the input file with a "_processed" suffix
    if output_filepath is None:
        output_filepath = input_filepath.replace(".csv", "_processed.csv")

    # Save the dataframe with populated "Subject" and "Body" columns to a CSV file
    enron_df.to_csv(output_filepath, index=False)

    return output_filepath

input_path = '/Users/vchintalapati/Downloads/emails.csv'
result_path = process_enron_emails(input_path)
print(f"Processed CSV saved at: {result_path}")

fixed_enron = pd.read_csv('/Users/vchintalapati/Downloads/emails_processed.csv')

fixed_enron = fixed_enron[['Subject','Body']]

fixed_enron.head(4)

fixed_enron.dropna(inplace=True)

fixed_enron1 = fixed_enron[fixed_enron['Subject'].str.len() >= 20]

fixed_enron2 = fixed_enron1[fixed_enron['Body'].str.len() >= 20]

fixed_enron2.head(5)

fixed_enron2.drop(columns={'subody'})

fixed_enron2 = fixed_enron2.reset_index(drop=True)

# fixed_enron2['subody'] = f"""<subject>{fixed_enron2['Subject']}</subject><body>{fixed_enron2['Body']}</body>"""

fixed_enron2['subody'] = fixed_enron2.apply(lambda row: f"<subject>{row['Subject']}</subject><body>{row['Body']}</body>", axis=1)

fixed_enron2

fixed_enron2['subody'][3]

fixed_enron2['subody_length']= fixed_enron2.apply(lambda row: len(row['subody']),axis=1)

fixed_enron2

fixed_enron2_sorted = fixed_enron2.sort_values(by='subody_length', ascending=True)

fixed_enron2_sorted

fixed_enron2_sorted = fixed_enron2_sorted.reset_index(drop=True)

print(fixed_enron2_sorted['subody'][145000])

fixed_enron2_sorted['subody_length'][40000]

truncated_enron = fixed_enron2_sorted[40000:41000]

fixed_enron2_sorted['subody_length'][150000]

input_json = {}
for i in range(150000,180000):
    input_json.update({"text":f"{fixed_enron2_sorted['subody'][i]}"})

input_json

input_list = [{"text": fixed_enron2_sorted['subody'][i]} for i in range(150000, 180000)]

input_list

import json

with open('output.jsonl', 'w') as f:
    for i in range(150000, 180000):
        json_obj = {"text": fixed_enron2_sorted['subody'][i]}
        f.write(json.dumps(json_obj) + '\n')

